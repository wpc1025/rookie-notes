lock cmpxchg 指令：CAS原理

Object o = new Object;
占用16个字节
markword 8字节
class pointer 4字节
以上统称为对象头
实例数据
补位


锁的四种状态：
无锁
偏向锁：当前线程的指针
轻量级锁：自旋锁、自适应自旋锁；当前线程栈里面会有一个LockRecord；当自旋次数超过一定次数 或 自旋线程数超过CPU核数的一半 就会转变成重量锁
重量级锁：向系统内核申请一个metux，将所有竞争锁的线程放到一个队列里面，非公平锁

以上四种锁都会在对象头的markword中进行标识

锁升级
锁降级：在某些特定情况下（GC）时发生，没有意义


锁消除
如StringBuffer，当其引用不可能被其他线程使用时，StringBuffer对象就不是共享资源，JVM会自动消除StringBuffer对象内部的锁

锁粗化


synchronized和ReentrantLock区别
1. 两者都是可重入锁
2. synchronized依赖于JVM，ReentrantLock依赖于API
3. ReentrantLock增加了一些高级功能：等待可中断、可实现公平锁、可实现选择性通知
4. 两者的性能已经相差无几

为什么要使用线程池？
1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性

Java提供了几种线程池？各自使用场景是什么？
1. FixedThreadPool：固定数量的线程池。线程池线程数量不变，当无空闲线程时，新的任务暂存一个任务队列。适用于满足资源管理需求，而需要限制线程数量的应用场景
2. SingleThreadPool：只有一个线程的线程池。适用于需要保证顺序的执行各个任务且在任意时间点，不会有多个线程是活动的应用场景
3. CachedThreadPool：可根据实际情况调整线程池数量的线程池。适用于执行很多短期异步任务的小程序
4. ScheduledThreadPool：给定的延迟后运行任务，或者定期执行任务

线程池的创建方式？
1. 使用Executors创建
	FixedThreadPool和SingleThreadPool，队列长度为Integer的最大值，可能堆积大量请求，造成OOM
	CachedThreadPool和ScheduledThreadPool：线程创建允许Integer的最大值，可能创建大量线程，造成OOM
2. 使用ThreadPoolExecutor的构造函数创建
3. 使用开源类库


为什么要有hashcode？
例如HashSet，在添加元素时，可以先判断hashCode是否一致，若一致，再使用equals进行判断，大大减少了equals的次数，提高了执行速度

hashCode与equals的相关规定？
1. 若对象相等，则hashCode一定相等
2. 若对象相等，对两个对象调用equals必定返回true
3. 两个对象有相同的hashCode，但不一定相等
4. equals被覆盖过，则hashCode方法也必须覆盖
5. hashCode的默认行为是对堆上的对象产生独特值，如果没有重写hashCode，则该Class对象无论如何都不会相等

为什么两个对象有相等的hashCode，也不一定相等？
hash碰撞

==与equals？
==：判断两个对象的地址是不是相等
equals：若未重写equals方法，则等价于==。重写了equals方法，则按照equals方法来，如String类就重写了equals方法

Java 工程师面试突击第 1 季-中华石杉老师

介绍一下消息队列MQ的应用场景/使用消息队列的好处？
1. 通过异步处理提高系统性能（削峰）
	如秒杀、促销活动，使用MQ异步消费，减少并发事务，降低数据库压力
2. 降低系统耦合性

使用消息队列会带来什么问题？
1. 系统可用性降低
	需要考虑消息丢失、MQ挂掉的问题
2. 系统复杂性提高
	需要考虑消息重复消费、处理消息丢失、消息顺序问题
3. 一致性问题
	若消费者未成功消费，就会导致数据不一致

--------------------------------------------------------------------------
引入消息队列之后如何保证高可用性？
如何保证消息不被重复消费呢？
如何保证消息的可靠性传输（如何处理消息丢失的问题）？
我该怎么保证从消息队列里拿到的数据按顺序执行？
如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
如果让你来开发一个消息队列中间件，你会怎么设计架构？
--------------------------------------------------------------------------

InnoDB和MyIsam两者的区别？
1. count运算上的区别：MyIsam缓存有表meta-data，因为count(*)如果结构良好，速度非常快，但是InnoDB没有
2. InnoDB支持事务、崩溃修复能力、外键，MyIsam没有
3. MyIsam适合读密集的表，InnoDB适合写密集的表

ArrayList和LinkedList有什么区别？
1. 都不是线程安全的
2. ArrayList是数组，LinkedList是双向链表结构
3. ArrayList插入删除O(n)，LinkedList插入删除为O(1)
4. ArrayList支持根据元素序号快速获取元素对象，LinkedList不支持
5. ArrayList的空间浪费主要体现在list列表的结尾会预留一定的内存容量，LinkedList主要是每个节点多存储了前进节点和后续节点的指针

List的遍历方式？
1. 实现了RandomAccess接口的list，优先选择普通for循环，其次foreach
2. 未实现的，优先选择Iterator遍历

HashMap的底层实现?
1. jdk1.8之前是数组加链表
2. jdk1.8之后是数组加链表/红黑树

红黑树的特点？
1. 每个节点非红即黑
2. 根节点总是黑色的
3. 如果节点是红色的， 那么子节点必须是黑色的
4. 每个叶子节点都是黑色的空节点
5. 从根节点到叶子节点或空子节点的路径，必须包含相同数目的黑色节点

红黑树的应用？
1. TreeMap、TreeSet已经JDK1.8之后的HashMap底层都用到了红黑树

为什么要用红黑树？
1. 解决二叉查找树某些情况下退化成一个线性结构的问题

红黑树如此优秀，为什么不直接使用红黑树？
因为为了维持红黑树的平衡，插入元素后可能需要通过左旋、右旋、变色操作维持平衡。为什么链表长度为8时，转变为红黑色，通过概率统计而得，这个值是查询成本和新增元素成本得出的最好的一个值。

HashMap和HashTable的区别？
1. 线程安全
2. 效率
3. HashMap中，Null可以作为键，HashTable中put进的减值只要有一个Null值，直接抛出NullPointException
4. HashMap初始容量为16，每次扩容将其扩展为原先容量的2倍。HashTable初始容量是11，每次扩容，容量为2n+1。
5. 底层数据结构不同

HashSet和HashMap的区别？
1. HashSet底层是基于HashMap实现的
2. 实现Set接口   实现Map接口
3. 存储对象      存储键值对
4. 调用add添加元素     调用Put添加元素
5. 使用对象的HashCode    使用key计算哈希
6. HashSet较HashMap慢

说一下转发和重定向的区别？
1. 转发是服务器行为，重定向是客户端行为
2. 地址栏：转发浏览器地址栏地址不变，重定向地址改变
3. 数据共享：转发可共享request中的数据，重定向不行
4. 效率：转发高，重定向低

在浏览器中输入url地址到显示主页的过程都使用了哪些协议？
DNS
TCP
IP
OPSF
ARP
HTTP

过程如下：
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器渲染页面
6. 连接结束

TCP三次握手？
1. 客户端发送SYN标志的数据包给服务端
2. 服务端发送带有SYN/ACK标志的数据包给客户端
3. 客户端发送带有ACK标志的数据包给服务端
以上步骤主要是为了确认客户端、服务端接收发送数据都正常


TCP四次挥手？
1. 客户端发送一个FIN，用来关闭客户端到服务端的数据传送
2. 服务端收到这个FIN，返回一个ACK，确认序号为收到的序号加1，和SYN一样，一个FIN将占用一个序号
3. 服务端关闭与客户端的连接，发送一个FIN给客户端
4. 客户端发送ACK报文确认，并将确认序号设置为序号加1

IP地址和MAC地址的区别？
1. 为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此屏蔽物理地址的差异
2. MAC地址又称为物理地址、硬件地址，每个网卡都有一个全球唯一的MAC地址

HTTP请求响应报文格式？
1. 请求行、请求头、请求正文
2. 状态行、响应头部、响应正文

为什么要使用索引？
1. 加快数据检索速度
2. 保证每一行数据的唯一性
3. 帮助服务器避免排序和临时表
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接


为什么不对表中的每一列都建立一个索引？
1. 增加、删除、修改数据时，要动态维护索引，降低数据的维护速度
2. 索引会占用物理空间
3. 创建索引和维护索引要耗费时间，时间随数据量的增加而增加

索引是如何提高查询速度的？
1. 将无序的数据变成相对有序的数据

使用索引的注意事项？
1. 避免where字句中对字段施加函数，会造成无法命中索引
2. 使用逻辑主键，不要使用业务主键
3. 尽量将每一列都设置为Not Null
4. 删除长期未使用的索引


MySQL主要有哪些索引？
1. 哈希索引
2. BTree索引

什么是覆盖索引？
1. 一个索引包含所有需要查询的字段值，不需要回表

进程和线程的区别？
1. 线程是比进程更小的一个执行单元
2. 一个进程可能包含多个线程，多个线程共享一块内存空间和一组系统资源
3. 线程在执行过程中可能会进行同步和互斥

进程间的通信方式？
1. 管道
2. 信号量
3. 消息队列
4. 信号
5. 共享内存
6. 套接字

线程间的通信方式？
1. 锁机制
2. 信号量机制
3. 信号机制

单例模式的好处？
1. 省略创建重量级对象的创建时间
2. new操作次数减少，对系统内存的使用频率也会降低，减轻GC压力，缩短GC停顿时间

Spring Bean的作用域？


Spring Bean的生命周期？
1. Bean容器找到配置文件中Spring Bean的定义
2. Bean容器利用java Reflection Api创建一个Bean实例
3. 如果涉及到一些属性值，使用Set方法设置一些属性值
4. 如果Bean实现了*Aware接口，就调用相应的方案
5. 执行 postProcessBeforeInitialization
6. afterPropertiesSet
7. 执行init-method指定的方法
8.执行DisposableBean接口的destroy方法
9.执行destroy-method指定的方法
https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484865&amp;idx=2&amp;sn=178c6e64e6c12172e77efdd669eb86a7&source=41#wechat_redirect


Spring事务的传播行为和隔离级别？



Spring MVC原理？
客户端发送请求
前端控制器DispatchServlet接收客户端请求
找到处理器映射HandlerMapping解析请求对应的Handler
HandlerAdapter会根据Handler来调用真正的处理器处理请求，并处理相应的业务逻辑
处理器返回一个模型视图ModelAndView
视图解析器进行解析
返回一个视图对象
前段控制器DispatchServlet渲染数据
将得到的视图对象返回给用户

Spring AOP IOC实现原理？
IOC 控制翻转也叫作依赖注入，利用JAVA反射机制
AOP 面向切面编程，利用代理模式，两种方式实现代理：动态代理，静态织入

Spring AOP和AspectJ AOP与什么区别？
运行时增强  编译时增强
基于代理    基于字节码操作

Spring单例Bean的线程安全问题如何解决？
1. 在Bean对象中避免定义可变的成员变量（不现实）
2. 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中

@Component @Bean的区别？
作用于类  作用于方法
@Bean注解比@Component的自定义性更强

介绍一下@SpringBootApplication注解
1. @EnableAutoConfiguration：启用Spring Boot的自动配置机制
2. @ComponentScan：扫描被@Component注解的Bean
3. @Configuration：允许在上下文中注册额外的bean或导入其他配置类

SpringBoot的自动配置是如何实现的？


redis为什么那么快？
1. 完全基于内存操作
2. C语言实现，优化过的数据结构
3. 使用单线程，无上下文切换的成本
4. 基于非阻塞的IO多路复用机制

Redis6.0之后为什么改用多线程？
redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是单线程
这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。

什么是热Key问题？如何解决？
热key问题是突然有几十万请求去访问redis上的某个特定的key，会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引起雪崩
解决方案如下：
1. 提前把热key打散到不同的服务器，降低压力
2. 加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询

什么是缓存击穿、缓存穿透、缓存雪崩？
1. 缓存击穿的概念是：单个key并发访问过高，过期时导致所有请求直接打到db上
解决方案：
	加锁更新
	将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象
2. 缓存穿透：查询不存在缓存中的数据，每次请求都会打到DB上
	加布隆过滤器
3. 缓存雪崩：当某一时刻发生大规模的缓存失效情况，如你的缓存服务器宕机，会有大量请求进来直接打到DB上，这样就可能导致整个系统的崩溃
解决方案：
	针对不同的key设置不同的过期时间，避免同时过期
	限流，如果redis宕机，可以限流，避免同时刻大量请求打到DB上
	二级缓存，同热key问题

redis的过期删除策略是什么？
惰性删除：
当我们查询key时才对key进行检查，如果已经达到过期时间，则删除
定期删除：
定期删除指的是没过一段时间对数据库做一次检查，删除里面的过期key。不可能对所有key做轮询删除，所以redis会随机取一些key做检查和删除

定期+惰性都没有删除过期的key怎么办？
走redis的内存淘汰机制：
	从已设置过期时间的key中，移除最近最少使用的key进行淘汰
	从已设置过期时间的key中，移除将要过期的key
	从已设置过期时间的key中，随机选择key淘汰
	从key中选择最近最少使用的key删除
	从key中随机选择key删除
	当内存达到阈值时，新写入操作报错

持久化方式有哪些？有什么区别？
RDB：
	可手动执行也可以根据配置定期执行，将某个时间点上的数据库状态保存到RDB文件中。RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态
	可通过SAVE或者BGSAVE命令生成RDB文件
	SAVE命令会阻塞Redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求。
	BGSAVE命令会fork出来一个子进程，然后由子进程负责生成RDB文件，父进程可以继续处理命令请求，不会阻塞进程
AOF：
	通过保存redis服务器所执行的写命令来记录数据库状态
	AOF通过追加、写入、同步三个步骤实现持久化机制：
		AOF持久化激活状态，服务器执行完写命令，写命令将会被追加append到aof_buf缓冲区的末尾
		在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过appendfsync来决定
			always
			everysec
			no

怎么实现redis的高可用？
两种方案：主从架构和哨兵模式
主从架构：
	主从模式是最简单的实现高可用的方案，核心就是主从同步，原理如下：
		1. slave发送sync命令到master
		2. master收到sync命令后，执行bgsave命令，生成一个RDB文件
		3. master将这段时间的写命令记录到缓存
		4. bgsave执行完毕之后，发送RDB文件到slave，slave执行
		5. master发送缓存中的写命令到slave，slave执行
哨兵模式：
主从方案的确定：master宕机，则不能写入数据，slave也就失去了作用，整个架构就不可用了，没有自动故障转移机制
哨兵方案具备自动故障转移、集群监控、消息通知等功能
哨兵可以监视多个主从服务器，并且在监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令，过程如下：
	1. 初始化sentinel，将普通的redis代码替换成sentinel专用代码
	2. 初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID
	3. 创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道
	4. 每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息
	5. 当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，每隔10秒发送info命令，更新master信息
	6. sentinel每隔1秒向服务器发送ping命令，如果某台服务器在配置的响应时间连续返回无效回复，将会被标记为下线状态
	7. 选举出领头sentinel，领头sentinel需要半数以上的sentinel同意
	8. 领头sentinel从已下线的master的所有slave中挑选一个，将其转换为master
	9. 让所有的slave改为从新的master复制数据
	10. 将原来的master设置为新的master服务器的从服务器

redis集群的原理？



redis的事务机制？
redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程中将一系列多个命令按照顺序一次性执行完成，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令被执行完毕，事务的执行过程如下：
1. 服务端收到客户端请求，以MULTI开始
2. 如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令
3. 收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端
WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。














