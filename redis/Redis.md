# Redis
## 一、简单动态字符串
### 1.1 数据结构
```C
struct sdshdr {
	// 记录buf数组中已使用字节的数量
	// 等于SDS所保存字符串的长度
	int len;
	// 记录buf数组中未使用字节的数量
	int free;
	// 字节数组，用于保存字符串
	char buf[];
}
```
### 1.2 SDS与C字符串的区别
1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符串时带来的内存重分配次数
	- 空间预分配
		- 修改后`len`属性小于1MB，则分配和len属性同样大小的未使用空间
		- 修改后`len`属性大于1MB，则分配1MB的未使用空间
    - 惰性空间释放
4. 二进制安全，SDS可以保存文本或二进制数据，C字符串只能保存文本
5. 兼容部分C字符串函数

## 二、链表
### 2.1 数据结构
#### 2.1.1 链表节点
```C
type struct listNode {
	// 前置节点
	struct listNode *prev;
	// 后置节点
	struct listNode *next;
	// 节点的值
	void *value;
}listNode;
```
#### 2.1.2 链表

```C
typedef struct list{
	// 表头节点
	listNode *head;
	// 表尾节点
	listNode *tail;
	// 链表所包含的节点数量
	unsigned long len;
	// 节点值复制函数
	void *(*dup) (void *ptr);
	// 节点值释放函数
	void (*free) (void *ptr);
	// 节点值对比函数
	int (*match)(void *ptr,void *key);
}list;
```
### 2.2 特性
1. **双端**：链表节点带有prev和next指针，获取某个节点的前置后置节点复杂度都是O(1)
2. **无环**：表头节点的prev和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
3. **带表头指针和表尾指针**：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)
4. **带链表长度计数器**：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)
5. **多态**：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值

## 三、字典

### 3.1 数据结构

#### 3.1.1 哈希表节点
```C
typedef struct dictEntry{
	// 键
	void *key;
	
	// 值
	union{
		void *val;
		uint64_tu64;
		int64_ts64;
	} v;
	
	// 指向下个哈希表节点，形成链表
	struct dictEntry *next;
} dictEntry;
```

#### 3.1.2 哈希表
```C
typedef struct dictht{
	// 哈希表数组
	dictEntry **table;
	
	// 哈希表大小
	unsigned long size;
	
	// 哈希表大小掩码，用于计算索引值
	// 总是等于 size - 1
	unsigned long sizemask;
	
	// 该哈希表已有节点数量
	unsigned long used;
} dictht;
```

#### 3.1.3 字典
```C
typedef struct dict{
	// 类型特定函数
	dictType *type;
	
	// 私有数据
	void *privdata;
	
	// 哈希表
	dictht ht[2];
	
	// rehash索引
	// 当 rehash 不在进行时，值为-1
	int rehashidx;
}
```

### 3.2 hash算法
使用特定类型的`hash函数`对`key`求hash值，然后再用值与`dictht的掩码`做`位与`运算

### 3.3 键冲突
采用`链地址`，将新添加的与已有键值对冲突的放在链表的首部，因为没有指向链表尾部的指针，所以放在首部，时间复杂度为O(1)

### 3.4 哈希表扩展和收缩的时机
1. 扩展
	- 服务器未进行`BGSAVE`或`BGREWRITEAOF`时，负载因子大于等于1
	- 服务器进行`BGSAVE`或`BGREWRITEAOF`时，负载因子大于等于5
2. 收缩
	- 当负载因子小于0.1时，哈希表执行收缩操作

**负载因子公式：**`ht[0].used / ht[0].size`

### 3.5 渐进式rehash
- 避免`rehash`对服务器性能造成影响，服务器分多次、渐进式地将`ht[0]`里面的键值对慢慢地`rehash`到`ht[1]`
- 步骤
	1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
	2. 字典中维护索引计数器`rehashindex`，将其值设置为0，表示rehash开始
	3. rehash期间，每次对字典进行添加、删除、查找或更新，程序除执行指定操作，还会将ht[0]哈希表中rehashindex索引上的所有键值对rehash到ht[1]
	4. 在某个时间点，ht[0]的所有键值对都会被rehash到ht[1]，这时`rehashindex`置为-1，表示rehash结束

## 四、 跳跃表

### 4.1 数据结构
#### 4.1.1 跳跃表节点
```C
typedef struct zskiplistNode{
	// 层
	struct zskiplistLevel{
		// 前进指针
		struct zskiplistNode *forward;
		// 跨度
		unsigned int span;
	} level[];
	// 后退指针
	struct zskiplistNode *backward;
	// 分值
	double score;
	// 成员对象
	robj *obj;
}zskiplistNode;
```

#### 4.1.2 跳跃表
```C
typedef struct zskiplist{
	// 表头节点和表尾节点
	struct skiplistNode *header, *tail;
	// 表中节点的数量，表头节点不计算在内
	unsigned long length;
	// 表中层数最大的节点的层数，不包含表头节点
	int level;
}zskiplist;
```
1. `header`：指向跳跃表的表头节点
2. `tail`：指向跳跃表的表尾节点
3. `level`：记录目前跳跃表内，除表头节点外层数最大的节点层数
4. `length`：记录跳跃表目前包含节点（表头节点不计算在内）的数量

### 4.2 特性
1. 有序数据结构，在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均`O(logN)`、最坏`O(N)`复杂度的节点查找。有序集合键的底层实现之一。
2. 每个跳跃表的层高都是1至32之间的随机数
3. 跳跃表节点按分值大小排序，当分值相同时，节点按照成员对象的大小进行排序
### 4.3 查找
![img](./4-1.png)

**查找19**
1. 从头结点开始，首先跟`23`比较
2. `19`小于`23`，降一层，找到`9`
3. 大于`9`，查找指针再往前走一步和`23`比较，小于`23`，查找指针到下一层继续查找。
4. 然后和`13`进行推断。大于`13`，查找指针再往前走一步和`23`比較，小于`23`，（此时查找指针在图中“3”位置处）此时这个值肯定在`13`结点和`23`结点之间。查找指针到下一层继续查找。
5. 此时，我们和`19`进行推断。找到了。

## 五、整数集合
- 集合键的底层实现之一，当集合只包含整数值元素，且数量不多时，Redis使用整数集合作为集合键的底层实现
- 集合中元素有序，不重复

### 5.1 数据结构
```C
	typedef struct intset{
		// 编码方式，由该属性确定 contents 数组元素的类型
		uint32_t encoding;
		// 集合包含的元素数量
		uint32_t length;
		// 保存元素的数组
		int8_t contents[];
	}intset;
```
### 5.2 升级
当将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

**升级步骤**
1. 根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，保证底层数组的有序性不变
3. 将新元素添加到底层数组里面

**升级的好处**
-  提升灵活性
-  节约内存

### 5.3 降级
整数集合不支持降级操作

## 六、压缩列表
- 压缩列表（`ziplist`）是列表键和哈希键的底层实现之一。当列表键只包含少量列表项，且列表项要么是小整数、要么是长度短的字符串，使用`ziplist`；当哈希键只包含少量键值对，且每个键值对的键和值是小整数或长度短的字符串时，使用`ziplist`。
- 是`Redis`为节约内存开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。可包含任意多个节点，每个节点保存一个字节数组或者一个整数值。

### 6.1 压缩列表的构成
![压缩列表的构成](./6-1.png)

### 6.2 压缩列表的节点构成
![压缩列表的节点构成](./6-2.png)

- `previous_entry_length`：记录了压缩列表中前一个节点的长度，`previous_entry_length`长度可以是1字节或5字节。程序可通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。压缩列表的从表尾向表头遍历就是使用这一原理实现的。
- `encoding`：记录了节点的`content`属性所保存数据的类型以及长度
- `content`：负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的`encoding`属性决定

### 6.3 连锁更新
当新增或者删除节点时，有可能造成后一节点的`previous_entry_length`属性无法存储前一节点的长度，这个时候就需要更新后一节点的长度，同样，可能会影响后面的节点。

## 七、数据库
### 7.1 服务器中的数据库
```C
struct redisServer{
	// 一个数组，保存着服务器中的所有数据库
	redisDb *db;
	
	// 服务器的数据库数量，默认16
	int dbnum;
};

typedef struct redisClient{
	// 记录客户端当前正在使用的数据库
	redisDB *db;
} redisClient;
```
- 初始化服务器时，程序会根据服务器状态的`dbnum`属性来决定应该创建多少个数据库，该属性由服务器配置的`database`选项决定，默认为16
- `SELECT`命令的原理：通过修改`redisClient.db`指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能

### 7.2 数据库键空间
```C
typedef struct redisDb{
	// 数据库键空间，保存着数据库中所有的键值对
	dict *dict;
} redisDb;
```
**数据库键空间例子**
![数据库键空间例子](./7-1.png)

- 数据库的键空间是一个字典，对数据库的新增键、删除键、获取键，以及`FLUSHDB`、`RANDOMMKEY`、`DBSIZE`命令等，实际上都是通过对键空间字典进行操作实现的
- 读写键空间时的维护操作
	- 根据键是否存在更新服务器的键空间命中`hit`次数或不命中`miss`次数
	- 更新键的`LRU`（最后一次使用时间），可用于计算键的闲置时间
	- 读取的键过期时，服务器会先删除这个过期键
	- 若该键被`WATCH`命令监控，服务器会标记该键为`dity`，从而让事务程序注意到这个键已经被修改过
	- 服务器每次修改一个键之后，都会对脏`dity`键计数器增1，这个计数器会触发服务器持久化及复制操作

### 7.3 设置键的生存时间或过期时间
```C
typedef struct redisDb{
	// 过期字典，保存着键的过期时间
	dict *expires;
} redisDb;
```

**带有过期时间的数据库示例**
![带有过期时间的数据库示例](./7-2.png)

- 设置过期时间有四种方式：
	- `EXPIRE`命令设置键的生存时间为多少秒
	- `PEXPIRE`命令设置键的生存时间为多少毫秒
	- `EXPIREAT`命令设置键在某一个秒单位时间戳过期
	- `PEXPIREAT`命令设置键在某一个毫秒单位时间戳过期
实际上以上四种方式都会转变为`PEXPIREAT`命令去设置键的过期时间
- `PERSIST`命令移除一个键的过期时间
- `TTL`命令返回以秒为单位的键剩余生存时间，`PTTL`命令则返回以毫秒为单位的键剩余时间

### 7.4 过期键删除策略
- 定时策略：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，理解删除键。对CPU时间不友好
- 惰性策略：每次从键空间获取键时，检索键是否过期，如果过期，就删除。对内存不友好
- 定期策略：每隔一段时间，程序对数据库进行检查，删除里面的过期键。难点是确定删除操作执行的时长和频率

- Redis服务器实际使用的是惰性删除和定期删除两种策略
- `SAVE`及`BGSAVE`命令生成RDB文件时，已过期的键不会保存在RDB文件中。主服务器载入RDB文件时，不会载入过期键，从服务器，会载入
- AOF文件写入时，若键过期，会向AOF文件追加一条`DEL`命令。AOF文件重写时，已过期的键不会保存在重写后的AOF文件中


## 八、RDB持久化

1. `RDB持久化`机制是为了解决`Redis`内存数据库在崩溃或所在服务器停机之后数据丢失的问题。通过`SAVE`或`BGSAVE`命令可以手动生成某一个时间点的`RDB`文件，也可以通过配置`Redis`配置文件`save`选项自动生成`RDB`文件。
2. `RDB`文件是一个经过压缩的二进制文件，由多个部分组成；对于不同类型键值对，`RDB`文件会使用不同的方式来保存他们。
3. `SAVE`命令会阻塞`Redis`服务器进程，直到`RDB`文件创建完毕为止，在服务器阻塞期间，服务器不能处理任何命令请求
4. `BGSAVE`命令会派生出一个子进程，然后由子进程负责创建`RDB`文件，服务器进程会继续处理命令请求
5. `RDB`文件的载入工作是在服务器启动时自动执行的，`AOF`持久化功能开启时，`AOF`文件载入优先级高于`RDB`文件
6. 在`BGSAVE`命令执行期间，服务器发送的`SAVE`、`BGSAVE`命令会被拒绝，防止产生竞争条件；`BGREWRITEAOF`命令会被延迟到`GBSAVE`命令执行完毕之后执行；在`BGREWRITEAOF`命令执行时，`BGSAVE`命令会被拒绝
7. `Redis`允许用户通过配置多个`save`选项或传入启动参数，让服务器每隔`100ms`自动执行`BGSAVE`命令，生成`RDB`文件。如`save 900 1`代表，服务器在900秒内，对数据库进行了至少一次的修改。
```C
struct redisServer {
	// 修改计数器
	long dirty;
	// 上一次执行保存的时间
	time_t lastsave;
};
```

## 九、AOF持久化
AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。服务器在启动时，可以通过载入和执行AOF文件中保存的命令还原服务器关闭之前的数据库状态。

### 9.1 AOF持久化的实现
AOF持久化的实现可以分为命令追加、文件写入、文件同步三个步骤

#### 9.1.1 命令追加
服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾

```C
struct redisServer{
	// AOF缓冲区
	sds aof_buf;
};
```

#### 9.1.2 AOF文件的写入和同步
- Redis的服务器进程就是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件则负责执行像`serverCron`函数这样需要定时执行的函数。在服务器每次结束一个时间循环之前，都会调用`flushAppendOnlyFile`函数，根据服务器配置的`appendsync`选项的值来决定是否需要将`aof_buf`缓冲区中的内容写入和保存到AOF文件中。

**appendsync选项的值**
- `always`：将`aof_buf`缓冲区中的所有内容写入并同步到AOF文件中
- `everysec`：将`aof_buf`缓冲区中的内容写入到AOF文件中，若上次同步时间距离现在超过一秒钟，则对AOF文件进行同步，该同步操作由一个线程负责执行
- `no`：将`aof_buf`缓冲区中的内容写入到AOF文件中，是否同步由操作系统决定

### 9.2 AOF的载入和数据还原

**AOF文件载入过程**
![AOF文件载入过程](./9-1.png)

### 9.3 AOF重写

- AOF持久化是通过保存被执行的写命令来记录数据库状态，随着服务器运行时间的流逝，AOF体积会越来越大，会对Redis服务器，甚至整个宿主机造成影响，且数据还原所需要的时间也会越来越多。
- AOF重写的实现原理，是读取当前数据库状态，然后用一条命令去记录键值对（当处理哈希表、集合、有序集合这四种带有多个元素的键值对时，若元素数量超过限制，会使用多条命令记录该键，防止客户输入缓冲区溢出），代替之前这个键值对的多条命令
- AOF后台重写`BGREWRITEAOF`命令的实现原理，创建一个子进程，同时，在子进程创建完成后，写入命令除了写入AOF缓冲区外，还会写入AOF重写缓冲区，因为AOF重写过程中，读取到的数据库状态可能与重写之后的数据库状态不一致，需要在AOF重写完成后，将AOF重写缓冲区中的内容写入新的AOF文件，才能保证数据库状态的一致性

## 十、复制






